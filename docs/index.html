 
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><!-- #BeginTemplate "/Templates/main.dwt" -->
<head>
<meta http-equiv="Content-Style-Type" content="text/css">
<link href="stylesheet.css" rel="stylesheet" type="text/css">
<!-- #BeginEditable "doctitle" -->
<title>The dbUnit framework - Home</title>
<!-- #EndEditable --> 
</head>
<body>
<table cellpadding="8" cellspacing="0">
  <col span="1" valign="top" align="left"> <tbody> 
  <tr> 
    <td class="menu" nowrap valign="top"><a href="index.html">Home</a><br>
      <br>
      <a href="components.html">Components</a><br>
      <a href="howto.html">Howto Guides</a><br>
      <a href="bestpractices.html">Best Practices</a><br>
      <a href="api/index.html">API Doc</a><br>
      <a href="faq.html">FAQ</a><br>
      <br>
      <a href="changes.html">News/Changes</a><br>
      <a href="download.html">Download</a><br>
      <a href="contact.html">Contact</a><br>
      <a href="resources.html">Resources</a><br>
      <p> <a href="http://sourceforge.net"><img alt="SourceForge Logo" border="0" height="31" width="88" src="http://sourceforge.net/sflogo.php?group_id=47439"></a> 
      </p>
    </td>
    <td valign="top"> <!-- #BeginEditable "body" -->
      <h2>The dbUnit database testing framework</h2>
            
      <p>The dbUnit database testing framework is a JUnit extension which sets 
        up your database in a known state before executing your tests. This framework 
        uses xml datasets (collection of data tables) and performs database operations 
        before and after each test. The dbUnit framework supports both the clean 
        insert and the refresh strategies. <br>
        <br>
        Something worth noting: dbUnit is using itself in its own test suite!	
      </p>
      <h2 ><a name="notes">Notes about database unit testing</a></h2>
      By Richard Dallaway (see <a href="resources.html">ressources</a>)<br>
	  <p>
      <cite>&quot;A good test set is self-sufficient and creates all the data 
      it needs. Testing can be simplified if you can get the database in a known 
      state before a test is run. One ways to do this is to have a separate unit 
      test database, which is under the control of the test cases: the test cases 
      clean out the database before starting any tests.<br>
      <br>
      [...]<br>
      <br>
      Deleting and inserting data for every test may seem like a big time over 
      head, but as tests use relatively little data, I find this approach to be 
      quick enough (especially if you're running against a local test database).<br>
      <br>
      [...]<br>
      <br>
      The downside is that you need more than one database - but remember, they 
      can all run on one server if necessary. The way I'm testing now needs four 
      databases (well, two at a pinch): <br>
      </cite> 
      <ol>
        <li><cite>The <strong>production database</strong>. Live data. No testing 
          on this database. </cite></li>
        <li><cite>Your <strong>local development database</strong>, which is where 
          most of the testing is carried out. </cite></li>
        <li><cite>A <strong>populated development database</strong>, possibly 
          shared by all developers so you can run your application and see it 
          work with realistic amounts of data, rather than the hand full of records 
          you have in your test database. You may not strictly need this, but 
          it's reassuring to see your app work with lots of data (i.e., a copy 
          of the production database's data). </cite></li>
        <li><cite>A <strong>deployment databas</strong>e, or integration database, 
          where the tests are run prior to deployment to make sure any local database 
          changes have been applied. If you're working alone, you may be able 
          to live without this one, but you'll have to be sure any database structure 
          or stored procedure changes have been made to the production database 
          before you go live with your code. </cite></li>
      </ol>
      <cite>
      With multiple database you have to make sure you keep the structure of the 
      databases in sync: if you change a table definition or a stored procedure 
      on your test machine, you'll have to remember to make those changes on the 
      live server. The deployment database should act as a reminder to make those 
      changes.&quot;</cite><br>
      <!-- #EndEditable --> 
	  <hr>
      <div align="center">
        <p><font size="2">Copyright &copy;2002, Manuel Laflamme, All Rights Reserved</font></p>
        <p><font size="1"><a href="index.html">Home</a> - <a href="components.html">Components</a> 
          - <a href="howto.html">Howto Guides</a> - <a href="bestpractices.html">Best 
          Practices</a> - <a href="api/index.html">API Doc</a> - <a href="faq.html">FAQ</a> 
          - <a href="changes.html">News &amp; Changes History</a> - <a href="download.html">Download</a> 
          - <a href="contact.html">Contact</a> - <a href="resources.html">Resources</a></font></p>
      </div>
    </td>
  </tr>
  </tbody> 
</table>
</body>
<!-- #EndTemplate --></html>

