<?xml version="1.0" encoding="ISO-8859-1"?>
<document><properties><title>The Dbunit Framework - Framework Components</title></properties><body><section>
	 
      <h2>Core Classes</h2>
      The following walks you through the core classes that make up DbUnit: 
      <ul>
        <li><a href="#dataset">IDataSet (org.dbunit.dataset)</a></li>
        <li><a href="#databaseconnection">IDatabaseConnection (org.dbunit.database)</a></li>
        <li><a href="#databaseoperation">DatabaseOperation (org.dbunit.operation)</a></li>
      </ul>
      <p>All the above are interfaces or abstract classes and you will find yourself 
        using implementations or subclasses.</p>
      <hr></hr>
      <h3><a name="dataset">IDataSet</a></h3>
      <p>The <a class="code">IDataSet</a> interface represents is a collection 
        of data from various tables. As explained later, these data is used to 
        execute setup operations on a target database. 
      <source>
public interface IDataSet
{
    /**
     * Returns names of tables in this dataset in proper sequence. Multiple
     * occurence of the same name may be returned if multiple tables having
     * the same name are present in the dataset.
     */
    public String[] getTableNames() throws DataSetException;

    /**
     * Returns the specified table metadata.
     */
    public ITableMetaData getTableMetaData(String tableName)
            throws DataSetException;

    /**
     * Returns the specified table.
     */
    public ITable getTable(String tableName) throws DataSetException;

    /**
     * Returns an iterator over the tables in this dataset in proper sequence.
     */
    public ITableIterator iterator() throws DataSetException;

    /**
     * Returns an iterator over the tables in this dataset in reverse sequence.
     */
    public ITableIterator reverseIterator() throws DataSetException;
}</source>
</p>
      <p>The <a class="code">IDataSet</a> implementations provided by the framework 
        are: 
      <ul>
        <li><a href="#FlatXmlDataSet">FlatXmlDataSet</a></li>
        <li><a href="#XmlDataSet">XmlDataSet</a></li>
        <li><a href="#DatabaseDataSet">DatabaseDataSet</a></li>
        <li><a href="#DefaultDataSet">DefaultDataSet</a></li>
        <li><a href="#CompositeDataSet">CompositeDataSet</a></li>
        <li><a href="#FilteredDataSet">FilteredDataSet</a></li>
        <li><a href="#QueryDataSet">QueryDataSet</a> <font color="#FF0000">(new)</font></li>
      </ul>
</p>      
      <h4><a name="FlatXmlDataSet">FlatXmlDataSet</a></h4>
      <p>The FlatXmlDataSet class has been introduced in version 
        1.2. I found that generic XML datasets were hard to write and to maintain. 
        This was particularly painful for tables having a lot of columns. </p>
      <p>In the flat XML format, each XML element corresponds to a table row. 
        Each XML element name corresponds to a table name. The XML attributes 
        correspond to table columns. Here is an example dataset containing the 
        same data than the XmlDataSet <a href="#originalxmlsample">example</a>:
      <source><![CDATA[
<!DOCTYPE dataset SYSTEM "my-dataset.dtd">
<dataset>
    <TEST_TABLE COLUMN0="row 0 col 0" COLUMN1="row 0 col 1"
                COLUMN2="row 0 col 2" COLUMN3="row 0 col 3"/>
    <TEST_TABLE COLUMN0="row 1 col 0" COLUMN3="row 1 col 3"/>
    <SECOND_TABLE COLUMN0="row 0 col 0" COLUMN1="row 0 col 1" />
    <SECOND_TABLE COLUMN0="row 1 col 0" COLUMN1="row 1 col 1" />
    <EMPTY_TABLE/>
</dataset>]]></source>
      </p>
      <p>Learn how to export your database data to this format <a href="howto.html#extract">here</a> 
      and how to generate a DTD representing your database schema <a href="howto.html#generatedtd">here</a>. 
      <b>Note that DbUnit does not automatically add a reference to your DTD when 
      you export a dataset. You must edit the output file to manually add the 
      DOCTYPE declaration.</b></p> 
      <h5>Null Values</h5>
      <p>To specify a null value, you simply have to omit its corresponding attribute. 
      In the above example, COLUMN1 and COLUMN2 are nulls for the second row of 
      TEST_TABLE. </p>
      <h5>Table metadata</h5>
      <p>DbUnit use the DTD referenced by the document type declaration as metadata. 
      DbUnit only support external system URI. The URI can be absolute or relative.</p> 
      <p> Example of system document type declaration: 
      <source><![CDATA[<!DOCTYPE dataset SYSTEM "my-dataset.dtd">]]></source>
      </p><p>If the xml document does not contain a document type declaration, the 
        metadata is generated from the first row of each table. This is highly 
        recommended to always provide a document type declaration since DbUnit 
        will think your table is missing some columns if the first row has one 
        or more null values. 
      </p>
      <a name="XmlDataSet"> 
      <h4>XmlDataSet </h4>
      </a> 
      <p>The XmlDataSet class provides the persistence support 
        to read from and write to the generic XML dataset format. This format 
        is very verbiose and must conform to the following DTD:
      <source><![CDATA[
<?xml version="1.0" encoding="UTF-8"?>
<!ELEMENT dataset (table+)>
<!ELEMENT table (column*, row*)>
<!ATTLIST table
    name CDATA #REQUIRED
>
<!ELEMENT column (#PCDATA)>
<!ELEMENT row (value | null | none)*>
<!ELEMENT value (#PCDATA)>
<!ELEMENT null EMPTY>
]]></source></p>
      <p><a name="originalxmlsample">Example of XML document:</a><br></br>
      <source><![CDATA[
<!DOCTYPE dataset SYSTEM "dataset.dtd">
<dataset>
    <table name="TEST_TABLE">
        <column>COLUMN0</column>
        <column>COLUMN1</column>
        <column>COLUMN2</column>
        <column>COLUMN3</column>
        <row>
            <value>row 0 col 0</value>
            <value>row 0 col 1</value>
            <value>row 0 col 2</value>
            <value>row 0 col 3</value>
        </row>
        <row>
            <value>row 1 col 0</value>
            <null/>
            <null/>
            <value>row 1 col 3</value>
        </row>
    </table>
    <table name="SECOND_TABLE">
        <column>COLUMN0</column>
        <column>COLUMN1</column>
        <row>
            <value>row 0 col 0</value>
            <value>row 0 col 1</value>
        </row>
        <row>
            <value>row 1 col 0</value>
            <value>row 1 col 1</value>
        </row>
    </table>
    <table name='EMPTY_TABLE'>
        <column>COLUMN0</column>
        <column>COLUMN1</column>
        <column>COLUMN2</column>
        <column>COLUMN3</column>
    </table>
</dataset>]]></source></p>
      <h4><a name="DatabaseDataSet">DatabaseDataSet</a></h4>
      <p>The DatabaseDataSet is an adapter class that allows access 
      to a database contents as a dataset. This class is not usually instantiated 
      directly but from the factory method <code>IDatabaseConnection.createDataSet()</code>.</p>
      <h4><a name="DefaultDataSet">DefaultDataSet</a></h4>
      <p>The DefaultDataSet class can be used to create datasets 
      programmatically.</p>
      <h4><a name="CompositeDataSet">CompositeDataSet</a></h4>
      <p>The CompositeDataSet class combines multiple datasets 
      into a single one at runtime.</p>
      <h4><a name="FilteredDataSet">FilteredDataSet</a></h4>
      <p>The FileteredDataSet class is is a decorator which exposes 
      only some tables from the decorated dataset.</p>
      <h4><a name="QueryDataSet">QueryDataSet</a></h4>
      <p>The QueryDataSet allows to easily manipulates multiple 
      <a href="./api/org/dbunit/database/IDatabaseConnection.html#createQueryTable(java.lang.String,%20java.lang.String)">query 
      tables</a>.</p>
      <h3><a name="databaseconnection">IDatabaseConnection</a></h3>
      <p>As its name implies, the IDatabaseConnection represent 
        a connection to a database. 
        </p>
      <p>The DbUnit framework provides two implementations:
      <ul>
        <li><a class="code">DatabaseConnection</a>, which is a JDBC Connection 
          adapter.</li>
        <li><a class="code">DatabaseDataSourceConnection</a>, which is a JDBC 
          DataSource adapter.<br></br>
        </li>
      </ul>
       </p>
      <h3><a name="databaseoperation">DatabaseOperation</a></h3>
      <p>The <a class="code">DatabaseOperation</a> abstract class defines operations 
        performed on a target database before and after each test. 
      <source><![CDATA[
public abstract class DatabaseOperation
{
    public static final IDatabaseOperation NONE = new DummyAction();
    public static final IDatabaseOperation UPDATE = new UpdateOperation();
    public static final IDatabaseOperation INSERT = new InsertOperation();
    public static final IDatabaseOperation REFRESH = new RefreshOperation();
    public static final IDatabaseOperation DELETE = new DeleteOperation();
    public static final IDatabaseOperation DELETE_ALL =
            new DeleteAllOperation();
    public static final IDatabaseOperation CLEAN_INSERT =
            new CompositeOperation(DELETE_ALL, INSERT);


    /**
     * Executes this operation on the specified database using the specified
     * dataset contents.
     *
     * @param connection the database connection.
     * @param dataSet the dataset to be used by this operation.
     */
    public abstract void execute(IDatabaseConnection connection,
            IDataSet dataSet) throws DatabaseUnitException, SQLException;

    private static class DummyAction extends DatabaseOperation
    {
        public void execute(IDatabaseConnection connection,
                IDataSet dataSet)
        {
        }
    }
}]]></source>
      </p>
        <p>Again, the framework provides several implementations. 
      <ul>
        <li><a href="#update">UPDATE</a></li>
        <li><a href="#insert">INSERT</a></li>
        <li><a href="#delete">DELETE</a></li>
        <li><a href="#deleteall">DELETE_ALL</a></li>
        <li><a href="#refresh">REFRESH</a></li>
        <li><a href="#cleaninsert">CLEAN_INSERT</a></li>
        <li><a href="#none">NONE</a></li>
        <li><a href="#CompositeOperation">CompositeOperation</a></li>
        <li><a href="#TransactionOperation">TransactionOperation</a></li>
        <li><a href="#IdentityInsertOperation">IdentityInsertOperation</a> </li>
      </ul>
      </p>
      <p>The two most usefull operations are <a href="#refresh">REFRESH</a> and 
        <a href="#cleanInsert">CLEAN_INSERT</a>. They 
        are the ones you will deal usualy with. They represent two opposite 
        testing strategies with different benefits and tradeoffs. </p>
      <p>The <a class="code">DatabaseOperation</a> class declaration: </p>
      <h4><a name="update">DatabaseOperation</a>.UPDATE</h4>
      <p>This operation updates the database from the dataset contents. This operation 
      assumes that table data already exists in the target database and fails 
      if this is not the case.</p>
      <h4><a name="insert">DatabaseOperation.INSERT</a></h4>
      <p>This operation inserts the dataset contents into the database. This operation 
      assumes that table data does not exist in the target database and fails 
      if this is not the case. To prevent problems with foreign keys, tables must 
      be sequenced appropriately in the dataset.</p>
      <h4><a name="delete">DatabaseOperation.DELETE</a></h4>
      <p>This operation deletes only the dataset contents from the database. This 
      operation does not delete the entire table contents but only data that are 
      present in the dataset.</p>
      <h4><a name="deleteall">DatabaseOperation.DELETE_ALL</a></h4>
      <p>This operation deletes entire target database table contents for each table 
      contained in dataset. In other words, if a dataset does not contain a particular 
      table, but that table exists in the database, the contents of that table 
      is not deleted. Deletes are performed on table in reverse sequence.</p>
      <h4><a name="refresh">DatabaseOperation.REFRESH</a></h4>
      <p>This operation literally refreshes dataset contents into the target database. 
      This means that data of existing rows are updated and non-existing row get 
      inserted. Any rows which exist in the database but not in dataset stay unaffected. 
      This approach is more appropriate for tests that assume other data may exist 
      in the database.</p>
      <p>As you understand, this is a very powerful operation. This strategy can 
      help you deal more easily with foreign key constraints, as you don't necessarily 
      need to insert data in a specific sequence.</p>
      <p>If they are correctly written, tests using this strategy can even be performed 
      on a populated database like a copy of a production database.</p>
      <h4><a name="cleaninsert">DatabaseOperation.CLEAN_INSERT</a></h4>
      <p>This composite operation performs a DELETE_ALL operation followed by an 
      INSERT operation. This is the safest approach to ensure that the database 
      is in a known state. This is appropriate for tests that require the database 
      to only contain a specific set of data.</p>
      <h4><a name="none">DatabaseOperation.NONE</a></h4>
      <p>This operation does absolutely nothing with the target database.</p>
      <h4><a name="CompositeOperation">CompositeOperation</a></h4>
      <p>This operation combines multiple operations into a single one.</p>
      <h4><a name="TransactionOperation">TransactionOperation</a></h4>
      <p>This operation decorates an operation and executes it within the context 
        of a transaction.</p>
      <h4><a name="IdentityInsertOperation">IdentityInsertOperation</a></h4>
      <p>This operation decorates an insert operation and disables the MS SQL 
        Server automatic identifier generation (IDENTITY) during its execution. 
        Use following constants InsertIdentityOperation.INSERT, InsertIdentityOperation.CLEAN_INSERT 
        or InsertIdentityOperation.REFRESH instead of those defined in DatabaseOperation.</p>
      </section></body></document>